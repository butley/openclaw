diff --git a/docs/local-patches.md b/docs/local-patches.md
new file mode 100644
index 00000000000..90098d69eed
--- /dev/null
+++ b/docs/local-patches.md
@@ -0,0 +1,52 @@
+# Local Patches (Clawdbot)
+
+This fork includes a set of local patches originally maintained as shell scripts under
+`/Users/lucasmachado/apps/bob-full/clawd/patches`. These changes are **applied directly to
+source files** (not dist) so they survive rebuilds.
+
+## Applied Patch Set (2026-02-03)
+
+- **WhatsApp Opus TTS**
+  - File: `src/tts/tts.ts`
+  - Treats `whatsapp` the same as `telegram` for Opus output selection.
+  - Adds a fast path in `resolveChannelId()` for `whatsapp`/`telegram`.
+
+- **TTS Caption for Logging**
+  - File: `src/agents/tools/tts-tool.ts`
+  - Prepends `ðŸ”Š <text>` and a blank line before `MEDIA:` output so voice-note
+    transcripts are logged alongside audio output.
+
+- **Audio Transcript Hook**
+  - File: `src/auto-reply/reply/get-reply.ts`
+  - After media understanding, emits a `message_received` hook when an audio
+    transcript exists (content prefixed with `ðŸŽ¤`).
+
+- **Brazil JID Resolution**
+  - New file: `src/web/inbound/brazil-jid-resolver.ts`
+  - Files updated: `src/web/inbound/send-api.ts`, `src/web/outbound.ts`,
+    `src/web/inbound/monitor.ts`, `src/web/active-listener.ts`
+  - Resolves 8â€‘digit vs 9â€‘digit Brazilian mobile numbers via `onWhatsApp()` and
+    caches results in `${CONFIG_DIR}/brazil-jid-cache.json`.
+
+- **TUI Dark Theme**
+  - File: `src/tui/theme/theme.ts`
+  - Darker backgrounds for user + tool blocks, with ANSI gray for success output.
+
+- **Chat Mirror (Web â†’ WhatsApp)**
+  - Files: `src/gateway/server-methods/chat.ts`, `src/gateway/server-chat.ts`,
+    `src/gateway/protocol/schema/logs-chat.ts`, `src/infra/agent-events.ts`
+  - Adds `mirror?: boolean` to `chat.send` params.
+  - When `mirror` is true and the session key is of the form
+    `agent:{agentId}:{channel}:{peerKind}:{peerId}`, final replies are mirrored
+    back to WhatsApp via `sendMessageWhatsApp`.
+
+## How to Reapply
+
+If you update or rebase from upstream, reapply these changes by:
+
+1. **Cherry-pick the patch branch**: `patches/2026-02-03` (preferred).
+2. If conflicts arise, reapply the modifications to the files listed above.
+3. Rebuild the project (`pnpm build` or the normal release flow) to regenerate `dist/`.
+
+The original patch scripts remain in `clawd/patches` for reference only; they target
+`dist/` in the npm package and are not used in this repo.
diff --git a/src/agents/tools/tts-tool.ts b/src/agents/tools/tts-tool.ts
index 1add5054db6..3cade95299a 100644
--- a/src/agents/tools/tts-tool.ts
+++ b/src/agents/tools/tts-tool.ts
@@ -36,10 +36,13 @@ export function createTtsTool(opts?: {
 
       if (result.success && result.audioPath) {
         const lines: string[] = [];
-        // Tag Telegram Opus output as a voice bubble instead of a file attachment.
+        // Tag Opus output as a voice bubble instead of a file attachment.
         if (result.voiceCompatible) {
           lines.push("[[audio_as_voice]]");
         }
+        // PATCH: Include TTS text as caption for logging
+        lines.push("ðŸ”Š " + text);
+        lines.push("");
         lines.push(`MEDIA:${result.audioPath}`);
         return {
           content: [{ type: "text", text: lines.join("\n") }],
diff --git a/src/auto-reply/reply/dispatch-from-config.ts b/src/auto-reply/reply/dispatch-from-config.ts
index a903300a20b..0af362bac95 100644
--- a/src/auto-reply/reply/dispatch-from-config.ts
+++ b/src/auto-reply/reply/dispatch-from-config.ts
@@ -6,6 +6,7 @@ import { resolveSessionAgentId } from "../../agents/agent-scope.js";
 import { loadSessionStore, resolveStorePath } from "../../config/sessions.js";
 import { logVerbose } from "../../globals.js";
 import { isDiagnosticsEnabled } from "../../infra/diagnostic-events.js";
+import { emitInboundMessageEvent } from "../../infra/inbound-events.js";
 import {
   logMessageProcessed,
   logMessageQueued,
@@ -147,25 +148,53 @@ export async function dispatchReplyFromConfig(params: {
 
   const inboundAudio = isInboundAudioContext(ctx);
   const sessionTtsAuto = resolveSessionTtsAuto(ctx, cfg);
+
+  // Extract common message data for hooks and WebSocket broadcast
+  const timestamp =
+    typeof ctx.Timestamp === "number" && Number.isFinite(ctx.Timestamp)
+      ? ctx.Timestamp
+      : undefined;
+  const messageIdForEvent =
+    ctx.MessageSidFull ?? ctx.MessageSid ?? ctx.MessageSidFirst ?? ctx.MessageSidLast;
+  const content =
+    typeof ctx.BodyForCommands === "string"
+      ? ctx.BodyForCommands
+      : typeof ctx.RawBody === "string"
+        ? ctx.RawBody
+        : typeof ctx.Body === "string"
+          ? ctx.Body
+          : "";
+  const channelId = (ctx.OriginatingChannel ?? ctx.Surface ?? ctx.Provider ?? "").toLowerCase();
+  const conversationId = ctx.OriginatingTo ?? ctx.To ?? ctx.From ?? undefined;
+
+  // Emit inbound message event for WebSocket broadcast to connected clients
+  emitInboundMessageEvent({
+    messageId: messageIdForEvent,
+    sessionKey,
+    channel: channelId,
+    accountId: ctx.AccountId,
+    from: ctx.From ?? "",
+    senderName: ctx.SenderName,
+    content,
+    timestamp,
+    chatType: ctx.ChatType === "group" ? "group" : "dm",
+    conversationId,
+    threadId: ctx.MessageThreadId,
+    hasMedia: Boolean(ctx.MediaType || ctx.MediaTypes?.length),
+    mediaType: ctx.MediaType,
+    metadata: {
+      to: ctx.To,
+      provider: ctx.Provider,
+      surface: ctx.Surface,
+      senderId: ctx.SenderId,
+      senderUsername: ctx.SenderUsername,
+      senderE164: ctx.SenderE164,
+    },
+  });
+
+  // Run message_received hooks
   const hookRunner = getGlobalHookRunner();
   if (hookRunner?.hasHooks("message_received")) {
-    const timestamp =
-      typeof ctx.Timestamp === "number" && Number.isFinite(ctx.Timestamp)
-        ? ctx.Timestamp
-        : undefined;
-    const messageIdForHook =
-      ctx.MessageSidFull ?? ctx.MessageSid ?? ctx.MessageSidFirst ?? ctx.MessageSidLast;
-    const content =
-      typeof ctx.BodyForCommands === "string"
-        ? ctx.BodyForCommands
-        : typeof ctx.RawBody === "string"
-          ? ctx.RawBody
-          : typeof ctx.Body === "string"
-            ? ctx.Body
-            : "";
-    const channelId = (ctx.OriginatingChannel ?? ctx.Surface ?? ctx.Provider ?? "").toLowerCase();
-    const conversationId = ctx.OriginatingTo ?? ctx.To ?? ctx.From ?? undefined;
-
     void hookRunner
       .runMessageReceived(
         {
@@ -179,7 +208,7 @@ export async function dispatchReplyFromConfig(params: {
             threadId: ctx.MessageThreadId,
             originatingChannel: ctx.OriginatingChannel,
             originatingTo: ctx.OriginatingTo,
-            messageId: messageIdForHook,
+            messageId: messageIdForEvent,
             senderId: ctx.SenderId,
             senderName: ctx.SenderName,
             senderUsername: ctx.SenderUsername,
diff --git a/src/auto-reply/reply/get-reply.ts b/src/auto-reply/reply/get-reply.ts
index 7066b4538b2..90879b4bc3c 100644
--- a/src/auto-reply/reply/get-reply.ts
+++ b/src/auto-reply/reply/get-reply.ts
@@ -12,6 +12,7 @@ import { DEFAULT_AGENT_WORKSPACE_DIR, ensureAgentWorkspace } from "../../agents/
 import { type OpenClawConfig, loadConfig } from "../../config/config.js";
 import { applyLinkUnderstanding } from "../../link-understanding/apply.js";
 import { applyMediaUnderstanding } from "../../media-understanding/apply.js";
+import { getGlobalHookRunner } from "../../plugins/hook-runner-global.js";
 import { defaultRuntime } from "../../runtime.js";
 import { resolveCommandAuthorization } from "../command-auth.js";
 import { SILENT_REPLY_TOKEN } from "../tokens.js";
@@ -122,6 +123,36 @@ export async function getReplyFromConfig(
       agentDir,
       activeModel: { provider, model },
     });
+    if (finalized.Transcript) {
+      const hookRunner = getGlobalHookRunner();
+      if (hookRunner?.hasHooks("message_received")) {
+        void hookRunner
+          .runMessageReceived(
+            {
+              from: finalized.From ?? "",
+              content: "ðŸŽ¤ " + finalized.Transcript,
+              timestamp: finalized.Timestamp,
+              metadata: {
+                to: finalized.To,
+                provider: finalized.Provider,
+                surface: finalized.Surface,
+                senderE164: finalized.SenderE164,
+                isTranscript: true,
+                originalBody: "<media:audio>",
+              },
+            },
+            {
+              channelId: (finalized.OriginatingChannel ??
+                finalized.Surface ??
+                finalized.Provider ??
+                "").toLowerCase(),
+              accountId: finalized.AccountId,
+              conversationId: finalized.OriginatingTo ?? finalized.To ?? finalized.From,
+            },
+          )
+          .catch(() => {});
+      }
+    }
     await applyLinkUnderstanding({
       ctx: finalized,
       cfg,
diff --git a/src/gateway/protocol/schema/logs-chat.ts b/src/gateway/protocol/schema/logs-chat.ts
index b8d0fe1ba45..8e1f044751b 100644
--- a/src/gateway/protocol/schema/logs-chat.ts
+++ b/src/gateway/protocol/schema/logs-chat.ts
@@ -40,6 +40,7 @@ export const ChatSendParamsSchema = Type.Object(
     attachments: Type.Optional(Type.Array(Type.Unknown())),
     timeoutMs: Type.Optional(Type.Integer({ minimum: 0 })),
     idempotencyKey: NonEmptyString,
+    mirror: Type.Optional(Type.Boolean()),
   },
   { additionalProperties: false },
 );
diff --git a/src/gateway/server-chat.ts b/src/gateway/server-chat.ts
index 953b26268a4..ccd77e3c512 100644
--- a/src/gateway/server-chat.ts
+++ b/src/gateway/server-chat.ts
@@ -200,6 +200,28 @@ export function createAgentEventHandler({
         broadcast("chat", payload);
       }
       nodeSendToSession(sessionKey, "chat", payload);
+
+      // Mirror to original channel if requested
+      const runContext = getAgentRunContext(clientRunId);
+      if (runContext?.mirror && text) {
+        try {
+          const keyParts = sessionKey.split(":").filter(Boolean);
+          // Format: agent:{agentId}:{channel}:{peerKind}:{peerId}
+          if (keyParts.length >= 5 && keyParts[0] === "agent") {
+            const channel = keyParts[2];
+            const peerId = keyParts.slice(4).join(":");
+            if (channel === "whatsapp" && peerId) {
+              import("../web/outbound.js").then(({ sendMessageWhatsApp }) => {
+                sendMessageWhatsApp(peerId, text, { verbose: false })
+                  .then(() => console.log(`[mirror] sent to ${channel}:${peerId}`))
+                  .catch((err) => console.warn(`[mirror] failed: ${err}`));
+              });
+            }
+          }
+        } catch (mirrorErr) {
+          console.warn(`[mirror] error: ${mirrorErr}`);
+        }
+      }
       return;
     }
     const payload = {
diff --git a/src/gateway/server-close.ts b/src/gateway/server-close.ts
index ea0323587a9..442dfd0dd0a 100644
--- a/src/gateway/server-close.ts
+++ b/src/gateway/server-close.ts
@@ -22,6 +22,7 @@ export function createGatewayCloseHandler(params: {
   dedupeCleanup: ReturnType<typeof setInterval>;
   agentUnsub: (() => void) | null;
   heartbeatUnsub: (() => void) | null;
+  inboundMessageUnsub: (() => void) | null;
   chatRunState: { clear: () => void };
   clients: Set<{ socket: { close: (code: number, reason: string) => void } }>;
   configReloader: { stop: () => Promise<void> };
@@ -95,6 +96,13 @@ export function createGatewayCloseHandler(params: {
         /* ignore */
       }
     }
+    if (params.inboundMessageUnsub) {
+      try {
+        params.inboundMessageUnsub();
+      } catch {
+        /* ignore */
+      }
+    }
     params.chatRunState.clear();
     for (const c of params.clients) {
       try {
diff --git a/src/gateway/server-methods-list.ts b/src/gateway/server-methods-list.ts
index 4f997c2dfb7..6f0befed6dc 100644
--- a/src/gateway/server-methods-list.ts
+++ b/src/gateway/server-methods-list.ts
@@ -111,4 +111,5 @@ export const GATEWAY_EVENTS = [
   "voicewake.changed",
   "exec.approval.requested",
   "exec.approval.resolved",
+  "message.inbound",
 ];
diff --git a/src/gateway/server-methods/chat.ts b/src/gateway/server-methods/chat.ts
index ba5347dc3fb..e3d832977bb 100644
--- a/src/gateway/server-methods/chat.ts
+++ b/src/gateway/server-methods/chat.ts
@@ -9,6 +9,7 @@ import { resolveEffectiveMessagesConfig, resolveIdentityName } from "../../agent
 import { resolveThinkingDefault } from "../../agents/model-selection.js";
 import { resolveAgentTimeoutMs } from "../../agents/timeout.js";
 import { dispatchInboundMessage } from "../../auto-reply/dispatch.js";
+import { registerAgentRunContext } from "../../infra/agent-events.js";
 import { createReplyDispatcher } from "../../auto-reply/reply/reply-dispatcher.js";
 import {
   extractShortModelName,
@@ -324,6 +325,7 @@ export const chatHandlers: GatewayRequestHandlers = {
       }>;
       timeoutMs?: number;
       idempotencyKey: string;
+      mirror?: boolean;
     };
     const stopCommand = isChatStopCommandText(p.message);
     const normalizedAttachments =
@@ -375,6 +377,7 @@ export const chatHandlers: GatewayRequestHandlers = {
     });
     const now = Date.now();
     const clientRunId = p.idempotencyKey;
+    registerAgentRunContext(clientRunId, { sessionKey: p.sessionKey, mirror: p.mirror });
 
     const sendPolicy = resolveSendPolicy({
       cfg,
@@ -561,6 +564,27 @@ export const chatHandlers: GatewayRequestHandlers = {
               sessionKey: p.sessionKey,
               message,
             });
+            if (p.mirror && combinedReply) {
+              try {
+                const keyParts = p.sessionKey.split(":").filter(Boolean);
+                // Format: agent:{agentId}:{channel}:{peerKind}:{peerId}
+                if (keyParts.length >= 5 && keyParts[0] === "agent") {
+                  const channel = keyParts[2];
+                  const peerId = keyParts.slice(4).join(":");
+                  if (channel === "whatsapp" && peerId) {
+                    import("../../web/outbound.js").then(({ sendMessageWhatsApp }) => {
+                      sendMessageWhatsApp(peerId, combinedReply, { verbose: false })
+                        .then(() =>
+                          context.logGateway.info(`[mirror] sent to ${channel}:${peerId}`),
+                        )
+                        .catch((err) => context.logGateway.warn(`[mirror] failed: ${err}`));
+                    });
+                  }
+                }
+              } catch (mirrorErr) {
+                context.logGateway.warn(`[mirror] error: ${mirrorErr}`);
+              }
+            }
           }
           context.dedupe.set(`chat:${clientRunId}`, {
             ts: Date.now(),
diff --git a/src/gateway/server.impl.ts b/src/gateway/server.impl.ts
index 9e5142f1351..d6fc469bb39 100644
--- a/src/gateway/server.impl.ts
+++ b/src/gateway/server.impl.ts
@@ -22,6 +22,7 @@ import { isDiagnosticsEnabled } from "../infra/diagnostic-events.js";
 import { logAcceptedEnvOption } from "../infra/env.js";
 import { createExecApprovalForwarder } from "../infra/exec-approval-forwarder.js";
 import { onHeartbeatEvent } from "../infra/heartbeat-events.js";
+import { onInboundMessageEvent } from "../infra/inbound-events.js";
 import { startHeartbeatRunner } from "../infra/heartbeat-runner.js";
 import { getMachineDisplayName } from "../infra/machine-name.js";
 import { ensureOpenClawCliOnPath } from "../infra/path-env.js";
@@ -411,6 +412,11 @@ export async function startGatewayServer(
     broadcast("heartbeat", evt, { dropIfSlow: true });
   });
 
+  // Subscribe to inbound message events and broadcast to connected WebSocket clients
+  const inboundMessageUnsub = onInboundMessageEvent((evt) => {
+    broadcast("message.inbound", evt, { dropIfSlow: true });
+  });
+
   let heartbeatRunner = startHeartbeatRunner({ cfg: cfgAtStart });
 
   void cron.start().catch((err) => logCron.error(`failed to start: ${String(err)}`));
@@ -565,6 +571,7 @@ export async function startGatewayServer(
     dedupeCleanup,
     agentUnsub,
     heartbeatUnsub,
+    inboundMessageUnsub,
     chatRunState,
     clients,
     configReloader,
diff --git a/src/infra/agent-events.ts b/src/infra/agent-events.ts
index 23557cdda61..a4bb2ff48a4 100644
--- a/src/infra/agent-events.ts
+++ b/src/infra/agent-events.ts
@@ -15,6 +15,7 @@ export type AgentRunContext = {
   sessionKey?: string;
   verboseLevel?: VerboseLevel;
   isHeartbeat?: boolean;
+  mirror?: boolean;
 };
 
 // Keep per-run counters so streams stay strictly monotonic per runId.
@@ -40,6 +41,9 @@ export function registerAgentRunContext(runId: string, context: AgentRunContext)
   if (context.isHeartbeat !== undefined && existing.isHeartbeat !== context.isHeartbeat) {
     existing.isHeartbeat = context.isHeartbeat;
   }
+  if (context.mirror !== undefined && existing.mirror !== context.mirror) {
+    existing.mirror = context.mirror;
+  }
 }
 
 export function getAgentRunContext(runId: string) {
diff --git a/src/infra/inbound-events.ts b/src/infra/inbound-events.ts
new file mode 100644
index 00000000000..2965c9e12bb
--- /dev/null
+++ b/src/infra/inbound-events.ts
@@ -0,0 +1,77 @@
+/**
+ * Inbound Message Events
+ *
+ * Provides a pub/sub mechanism for broadcasting inbound messages
+ * to connected WebSocket clients (e.g., dashboard).
+ */
+
+export type InboundMessageEventPayload = {
+  /** Unique message ID */
+  messageId?: string;
+  /** Session key for routing */
+  sessionKey?: string;
+  /** Channel the message came from (whatsapp, telegram, discord, etc.) */
+  channel: string;
+  /** Account ID within the channel */
+  accountId?: string;
+  /** Sender identifier (phone, username, etc.) */
+  from: string;
+  /** Sender display name */
+  senderName?: string;
+  /** Message content */
+  content: string;
+  /** Unix timestamp in milliseconds */
+  timestamp: number;
+  /** Chat type (dm, group) */
+  chatType?: "dm" | "group";
+  /** Conversation/chat ID */
+  conversationId?: string;
+  /** Thread ID if applicable */
+  threadId?: string;
+  /** Whether message has media */
+  hasMedia?: boolean;
+  /** Media type if present */
+  mediaType?: string;
+  /** Additional metadata */
+  metadata?: Record<string, unknown>;
+};
+
+type InboundEventListener = (evt: InboundMessageEventPayload) => void;
+
+const listeners = new Set<InboundEventListener>();
+
+/**
+ * Emit an inbound message event to all registered listeners.
+ */
+export function emitInboundMessageEvent(
+  event: Omit<InboundMessageEventPayload, "timestamp"> & { timestamp?: number },
+): void {
+  const enriched: InboundMessageEventPayload = {
+    ...event,
+    timestamp: event.timestamp ?? Date.now(),
+  };
+
+  for (const listener of listeners) {
+    try {
+      listener(enriched);
+    } catch {
+      /* ignore listener errors */
+    }
+  }
+}
+
+/**
+ * Register a listener for inbound message events.
+ * Returns an unsubscribe function.
+ */
+export function onInboundMessageEvent(listener: InboundEventListener): () => void {
+  listeners.add(listener);
+  return () => listeners.delete(listener);
+}
+
+/**
+ * Check if any listeners are registered.
+ */
+export function hasInboundEventListeners(): boolean {
+  return listeners.size > 0;
+}
diff --git a/src/tts/tts.ts b/src/tts/tts.ts
index 0f47c02a972..6e550240725 100644
--- a/src/tts/tts.ts
+++ b/src/tts/tts.ts
@@ -474,14 +474,21 @@ export function setLastTtsAttempt(entry: TtsStatusEntry | undefined): void {
 }
 
 function resolveOutputFormat(channelId?: string | null) {
-  if (channelId === "telegram") {
+  if (channelId === "telegram" || channelId === "whatsapp") {
     return TELEGRAM_OUTPUT;
   }
   return DEFAULT_OUTPUT;
 }
 
 function resolveChannelId(channel: string | undefined): ChannelId | null {
-  return channel ? normalizeChannelId(channel) : null;
+  if (!channel) {
+    return null;
+  }
+  const lower = String(channel).toLowerCase().trim();
+  if (lower === "whatsapp" || lower === "telegram") {
+    return lower as ChannelId;
+  }
+  return normalizeChannelId(channel);
 }
 
 function resolveEdgeOutputFormat(config: ResolvedTtsConfig): string {
diff --git a/src/tui/theme/theme.ts b/src/tui/theme/theme.ts
index 18fa5f4d44a..809894cfb44 100644
--- a/src/tui/theme/theme.ts
+++ b/src/tui/theme/theme.ts
@@ -15,12 +15,12 @@ const palette = {
   accent: "#F6C453",
   accentSoft: "#F2A65A",
   border: "#3C414B",
-  userBg: "#2B2F36",
+  userBg: "#1a1a1a",
   userText: "#F3EEE0",
   systemText: "#9BA3B2",
-  toolPendingBg: "#1F2A2F",
+  toolPendingBg: "#12151a",
   toolSuccessBg: "#1E2D23",
-  toolErrorBg: "#2F1F1F",
+  toolErrorBg: "#181212",
   toolTitle: "#F6C453",
   toolOutput: "#E1DACB",
   quote: "#8CC8FF",
@@ -35,6 +35,7 @@ const palette = {
 
 const fg = (hex: string) => (text: string) => chalk.hex(hex)(text);
 const bg = (hex: string) => (text: string) => chalk.bgHex(hex)(text);
+const bgAnsi = (code: number) => (text: string) => chalk.bgAnsi256(code)(text);
 
 const syntaxTheme = createSyntaxTheme(fg(palette.code));
 
@@ -73,7 +74,7 @@ export const theme = {
   toolTitle: fg(palette.toolTitle),
   toolOutput: fg(palette.toolOutput),
   toolPendingBg: bg(palette.toolPendingBg),
-  toolSuccessBg: bg(palette.toolSuccessBg),
+  toolSuccessBg: bgAnsi(236), // dark gray
   toolErrorBg: bg(palette.toolErrorBg),
   border: fg(palette.border),
   bold: (text: string) => chalk.bold(text),
diff --git a/src/web/active-listener.ts b/src/web/active-listener.ts
index 81170d3084f..6da62d37cb0 100644
--- a/src/web/active-listener.ts
+++ b/src/web/active-listener.ts
@@ -24,6 +24,7 @@ export type ActiveWebListener = {
     participant?: string,
   ) => Promise<void>;
   sendComposingTo: (to: string) => Promise<void>;
+  onWhatsApp?: (jid: string) => Promise<Array<{ exists?: boolean; jid?: string }>>;
   close?: () => Promise<void>;
 };
 
diff --git a/src/web/inbound/brazil-jid-resolver.ts b/src/web/inbound/brazil-jid-resolver.ts
new file mode 100644
index 00000000000..4e6207954d7
--- /dev/null
+++ b/src/web/inbound/brazil-jid-resolver.ts
@@ -0,0 +1,240 @@
+/**
+ * Brazil WhatsApp JID Resolver
+ *
+ * Handles the legacy 8-digit vs 9-digit mobile number issue in Brazil.
+ * Uses Baileys' onWhatsApp() to discover the correct registered JID.
+ */
+
+import fs from "node:fs";
+import path from "node:path";
+import { CONFIG_DIR } from "../../utils.js";
+
+const CACHE_FILE = path.join(CONFIG_DIR, "brazil-jid-cache.json");
+const CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days
+
+type CacheEntry = {
+  jid: string;
+  originalInput: string;
+  variant: string;
+  timestamp: number;
+};
+
+// In-memory cache (persisted to disk)
+let jidCache: Record<string, CacheEntry> | null = null;
+
+/**
+ * Load cache from disk
+ */
+function loadCache(): Record<string, CacheEntry> {
+  if (jidCache !== null) {
+    return jidCache;
+  }
+
+  try {
+    if (fs.existsSync(CACHE_FILE)) {
+      const data = JSON.parse(fs.readFileSync(CACHE_FILE, "utf-8")) as {
+        entries?: Record<string, CacheEntry>;
+      };
+      jidCache = data.entries || {};
+    } else {
+      jidCache = {};
+    }
+  } catch {
+    jidCache = {};
+  }
+  return jidCache;
+}
+
+/**
+ * Save cache to disk
+ */
+function saveCache(): void {
+  try {
+    fs.mkdirSync(path.dirname(CACHE_FILE), { recursive: true });
+    fs.writeFileSync(
+      CACHE_FILE,
+      JSON.stringify(
+        {
+          entries: jidCache ?? {},
+          updatedAt: new Date().toISOString(),
+        },
+        null,
+        2,
+      ),
+    );
+  } catch (err) {
+    console.error("[brazil-jid] Failed to save cache:", (err as Error).message);
+  }
+}
+
+/**
+ * Check if a number is a Brazilian mobile number that needs resolution
+ */
+export function isBrazilianMobile(digits: string): boolean {
+  // Must start with 55 (Brazil country code)
+  if (!digits.startsWith("55")) {
+    return false;
+  }
+
+  // After country code: 2-digit area code + 8 or 9 digit local number
+  // Area codes: 11-99
+  const afterCountryCode = digits.slice(2);
+
+  // Total length should be 10 (8-digit) or 11 (9-digit) after country code
+  if (afterCountryCode.length < 10 || afterCountryCode.length > 11) {
+    return false;
+  }
+
+  const areaCode = afterCountryCode.slice(0, 2);
+  const areaNum = Number.parseInt(areaCode, 10);
+
+  // Valid area codes are 11-99
+  if (areaNum < 11 || areaNum > 99) {
+    return false;
+  }
+
+  const localNumber = afterCountryCode.slice(2);
+
+  // Mobile numbers start with 9 (after area code)
+  // 8-digit: 9XXXXXXX (first digit is 9)
+  // 9-digit: 9XXXXXXXX (first digit is 9)
+  if (localNumber.length >= 8 && localNumber.length <= 9) {
+    // For 9-digit, first digit should be 9
+    if (localNumber.length === 9 && localNumber[0] === "9") {
+      return true;
+    }
+    // For 8-digit legacy, first digit should be 6-9 (mobile range)
+    if (localNumber.length === 8 && ["6", "7", "8", "9"].includes(localNumber[0])) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/**
+ * Generate both 8-digit and 9-digit variants for a Brazilian number
+ */
+export function generateBrazilianVariants(digits: string): string[] {
+  if (!digits.startsWith("55")) {
+    return [digits];
+  }
+
+  const areaCode = digits.slice(2, 4);
+  const localNumber = digits.slice(4);
+
+  const variants: string[] = [];
+
+  if (localNumber.length === 9 && localNumber.startsWith("9")) {
+    // Has 9-digit format: try as-is and without leading 9
+    variants.push(digits); // 9-digit
+    variants.push(`55${areaCode}${localNumber.slice(1)}`); // 8-digit
+  } else if (localNumber.length === 8) {
+    // Has 8-digit format: try as-is and with leading 9
+    variants.push(digits); // 8-digit
+    variants.push(`55${areaCode}9${localNumber}`); // 9-digit
+  } else {
+    variants.push(digits);
+  }
+
+  return variants;
+}
+
+type OnWhatsAppResult = { exists?: boolean; jid?: string };
+
+type OnWhatsAppApi = {
+  onWhatsApp: (jid: string) => Promise<Array<OnWhatsAppResult>>;
+};
+
+/**
+ * Resolve the correct WhatsApp JID for a Brazilian number
+ *
+ * @param sock - Baileys socket with onWhatsApp method
+ * @param inputJid - The input JID (e.g., "5531996348700@s.whatsapp.net")
+ * @returns The verified JID or original if not Brazilian/not found
+ */
+export async function resolveBrazilianJid(sock: OnWhatsAppApi, inputJid: string): Promise<string> {
+  if (!sock?.onWhatsApp) {
+    return inputJid;
+  }
+
+  // Extract digits from JID
+  const match = inputJid.match(/^(\d+)@s\.whatsapp\.net$/i);
+  if (!match) {
+    return inputJid; // Not a user JID, return as-is
+  }
+
+  const digits = match[1];
+
+  // Only process Brazilian mobile numbers
+  if (!isBrazilianMobile(digits)) {
+    return inputJid;
+  }
+
+  // Check cache first
+  const cache = loadCache();
+  const cacheKey =
+    digits.length === 13 ? digits : `55${digits.slice(2, 4)}9${digits.slice(4)}`; // Normalize to 9-digit for cache key
+  const cached = cache[cacheKey];
+
+  if (cached && cached.jid && Date.now() - cached.timestamp < CACHE_TTL_MS) {
+    console.log(`[brazil-jid] Cache hit: ${digits} â†’ ${cached.jid}`);
+    return cached.jid;
+  }
+
+  // Generate variants to check
+  const variants = generateBrazilianVariants(digits);
+  console.log(`[brazil-jid] Checking variants for ${digits}:`, variants);
+
+  // Query WhatsApp for each variant
+  for (const variant of variants) {
+    const testJid = `${variant}@s.whatsapp.net`;
+    try {
+      const [result] = await sock.onWhatsApp(testJid);
+      if (result?.exists) {
+        const verifiedJid = result.jid || testJid;
+        console.log(`[brazil-jid] Found: ${digits} â†’ ${verifiedJid}`);
+
+        // Cache the result
+        cache[cacheKey] = {
+          jid: verifiedJid,
+          originalInput: digits,
+          variant,
+          timestamp: Date.now(),
+        };
+        jidCache = cache;
+        saveCache();
+
+        return verifiedJid;
+      }
+    } catch (err) {
+      console.warn(`[brazil-jid] Query failed for ${variant}:`, (err as Error).message);
+    }
+  }
+
+  console.log(`[brazil-jid] No match found for ${digits}, using original`);
+  return inputJid;
+}
+
+/**
+ * Clear a specific entry from the cache
+ */
+export function clearCacheEntry(digits: string): boolean {
+  const cache = loadCache();
+  const normalizedKey = digits.replace(/\D/g, "");
+  if (cache[normalizedKey]) {
+    delete cache[normalizedKey];
+    jidCache = cache;
+    saveCache();
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Clear the entire cache
+ */
+export function clearCache(): void {
+  jidCache = {};
+  saveCache();
+}
diff --git a/src/web/inbound/monitor.ts b/src/web/inbound/monitor.ts
index c7cfabeba33..3187eef4ef3 100644
--- a/src/web/inbound/monitor.ts
+++ b/src/web/inbound/monitor.ts
@@ -364,6 +364,7 @@ export async function monitorWebInbox(options: {
     sock: {
       sendMessage: (jid: string, content: AnyMessageContent) => sock.sendMessage(jid, content),
       sendPresenceUpdate: (presence, jid?: string) => sock.sendPresenceUpdate(presence, jid),
+      onWhatsApp: (jid: string) => sock.onWhatsApp(jid),
     },
     defaultAccountId: options.accountId,
   });
@@ -399,5 +400,6 @@ export async function monitorWebInbox(options: {
     },
     // IPC surface (sendMessage/sendPoll/sendReaction/sendComposingTo)
     ...sendApi,
+    onWhatsApp: (jid: string) => sock.onWhatsApp(jid),
   } as const;
 }
diff --git a/src/web/inbound/send-api.ts b/src/web/inbound/send-api.ts
index 7deb9540dbd..44689d8efae 100644
--- a/src/web/inbound/send-api.ts
+++ b/src/web/inbound/send-api.ts
@@ -2,14 +2,35 @@ import type { AnyMessageContent, WAPresence } from "@whiskeysockets/baileys";
 import type { ActiveWebSendOptions } from "../active-listener.js";
 import { recordChannelActivity } from "../../infra/channel-activity.js";
 import { toWhatsappJid } from "../../utils.js";
+import { resolveBrazilianJid } from "./brazil-jid-resolver.js";
 
 export function createWebSendApi(params: {
   sock: {
     sendMessage: (jid: string, content: AnyMessageContent) => Promise<unknown>;
     sendPresenceUpdate: (presence: WAPresence, jid?: string) => Promise<unknown>;
+    onWhatsApp?: (jid: string) => Promise<Array<{ exists?: boolean; jid?: string }>>;
   };
   defaultAccountId: string;
 }) {
+  const resolveJid = async (to: string) => {
+    const jid = toWhatsappJid(to);
+    if (!params.sock.onWhatsApp) {
+      return jid;
+    }
+    try {
+      return await resolveBrazilianJid(
+        { onWhatsApp: params.sock.onWhatsApp },
+        jid,
+      );
+    } catch (err) {
+      console.warn(
+        "[send-api] Brazil JID resolution failed, using original:",
+        (err as Error).message,
+      );
+      return jid;
+    }
+  };
+
   return {
     sendMessage: async (
       to: string,
@@ -18,7 +39,7 @@ export function createWebSendApi(params: {
       mediaType?: string,
       sendOptions?: ActiveWebSendOptions,
     ): Promise<{ messageId: string }> => {
-      const jid = toWhatsappJid(to);
+      const jid = await resolveJid(to);
       let payload: AnyMessageContent;
       if (mediaBuffer && mediaType) {
         if (mediaType.startsWith("image/")) {
@@ -65,7 +86,7 @@ export function createWebSendApi(params: {
       to: string,
       poll: { question: string; options: string[]; maxSelections?: number },
     ): Promise<{ messageId: string }> => {
-      const jid = toWhatsappJid(to);
+      const jid = await resolveJid(to);
       const result = await params.sock.sendMessage(jid, {
         poll: {
           name: poll.question,
@@ -91,7 +112,7 @@ export function createWebSendApi(params: {
       fromMe: boolean,
       participant?: string,
     ): Promise<void> => {
-      const jid = toWhatsappJid(chatJid);
+      const jid = await resolveJid(chatJid);
       await params.sock.sendMessage(jid, {
         react: {
           text: emoji,
@@ -105,7 +126,7 @@ export function createWebSendApi(params: {
       } as AnyMessageContent);
     },
     sendComposingTo: async (to: string): Promise<void> => {
-      const jid = toWhatsappJid(to);
+      const jid = await resolveJid(to);
       await params.sock.sendPresenceUpdate("composing", jid);
     },
   } as const;
diff --git a/src/web/outbound.ts b/src/web/outbound.ts
index 1df95798933..a6d3086fbbc 100644
--- a/src/web/outbound.ts
+++ b/src/web/outbound.ts
@@ -8,9 +8,30 @@ import { normalizePollInput, type PollInput } from "../polls.js";
 import { toWhatsappJid } from "../utils.js";
 import { type ActiveWebSendOptions, requireActiveWebListener } from "./active-listener.js";
 import { loadWebMedia } from "./media.js";
+import { resolveBrazilianJid } from "./inbound/brazil-jid-resolver.js";
 
 const outboundLog = createSubsystemLogger("gateway/channels/whatsapp").child("outbound");
 
+async function resolveJidWithBrazil(
+  active: { onWhatsApp?: (jid: string) => Promise<Array<{ exists?: boolean; jid?: string }>> },
+  to: string,
+) {
+  const jid = toWhatsappJid(to);
+  if (!active.onWhatsApp) {
+    return jid;
+  }
+  try {
+    const resolved = await resolveBrazilianJid({ onWhatsApp: active.onWhatsApp }, jid);
+    if (resolved !== jid) {
+      outboundLog.info(`[brazil-jid] Resolved ${jid} -> ${resolved}`);
+    }
+    return resolved;
+  } catch (err) {
+    outboundLog.warn(`[brazil-jid] Resolution failed: ${(err as Error).message}`);
+    return jid;
+  }
+}
+
 export async function sendMessageWhatsApp(
   to: string,
   body: string,
@@ -40,7 +61,7 @@ export async function sendMessageWhatsApp(
     to,
   });
   try {
-    const jid = toWhatsappJid(to);
+    const jid = await resolveJidWithBrazil(active, to);
     let mediaBuffer: Buffer | undefined;
     let mediaType: string | undefined;
     if (options.mediaUrl) {
@@ -148,7 +169,7 @@ export async function sendPollWhatsApp(
     to,
   });
   try {
-    const jid = toWhatsappJid(to);
+    const jid = await resolveJidWithBrazil(active, to);
     const normalized = normalizePollInput(poll, { maxOptions: 12 });
     outboundLog.info(`Sending poll -> ${jid}: "${normalized.question}"`);
     logger.info(
